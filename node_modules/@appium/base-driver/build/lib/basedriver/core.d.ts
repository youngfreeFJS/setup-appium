export type Driver = import('@appium/types').Driver;
export type Constraints = import('@appium/types').Constraints;
export type ServerArgs = import('@appium/types').ServerArgs;
export type EventHistory = import('@appium/types').EventHistory;
export type AppiumLogger = import('@appium/types').AppiumLogger;
export type StringRecord = import('@appium/types').StringRecord;
export type BaseDriverCapConstraints = import('@appium/types').BaseDriverCapConstraints;
export type Capabilities<C extends Readonly<Record<string, import("@appium/types").Constraint>> = typeof import("@appium/types").BASE_DESIRED_CAP_CONSTRAINTS, Extra extends void | import("@appium/types").StringRecord = void> = import('@appium/types').Capabilities<C, Extra>;
export type W3CCapabilities<T extends import("@appium/types").StringRecord = {}> = import('@appium/types').W3CCapabilities<T>;
export type Core<C extends Readonly<Record<string, import("@appium/types").Constraint>>> = import('@appium/types').Core<C>;
export type DriverOpts<C extends Readonly<Record<string, import("@appium/types").Constraint>>> = import('@appium/types').DriverOpts<C>;
/**
 * @template {Constraints} [C=BaseDriverCapConstraints]
 * @implements {Core<C>}
 */
export class DriverCore<C extends Readonly<Record<string, import("@appium/types").Constraint>> = typeof import("@appium/types").BASE_DESIRED_CAP_CONSTRAINTS> implements Core<C> {
    /**
     * Make the basedriver version available so for any driver which inherits from this package, we
     * know which version of basedriver it inherited from
     */
    static baseVersion: any;
    /** @type {import('@appium/types').ExecuteMethodMap<DriverCore>} */
    static executeMethodMap: import('@appium/types').ExecuteMethodMap<DriverCore>;
    /**
     * @param {DriverOpts<C>} opts
     * @param {boolean} [shouldValidateCaps]
     */
    constructor(opts?: DriverOpts<C>, shouldValidateCaps?: boolean | undefined);
    /**
     * @type {string?}
     */
    sessionId: string | null;
    /**
     * @type {import('@appium/types').DriverOpts<C>}
     */
    opts: import('@appium/types').DriverOpts<C>;
    /**
     * @type {ServerArgs}
     */
    initialOpts: ServerArgs;
    helpers: import("@appium/types").DriverHelpers<any>;
    /**
     * basePath is used for several purposes, for example in setting up
     * proxying to other drivers, since we need to know what the base path
     * of any incoming request might look like. We set it to the default
     * initially but it is automatically updated during any actual program
     * execution by the routeConfiguringFunction, which is necessarily run as
     * the entrypoint for any Appium server
     */
    basePath: string;
    relaxedSecurityEnabled: boolean;
    /** @type {string[]} */
    allowInsecure: string[];
    /** @type {string[]} */
    denyInsecure: string[];
    newCommandTimeoutMs: number;
    implicitWaitMs: number;
    /** @type {string[]} */
    locatorStrategies: string[];
    /** @type {string[]} */
    webLocatorStrategies: string[];
    /** @type {Driver[]} */
    managedDrivers: Driver[];
    /** @type {NodeJS.Timeout?} */
    noCommandTimer: NodeJS.Timeout | null;
    /** @type {EventHistory} */
    _eventHistory: EventHistory;
    /** @type {NodeJS.EventEmitter} */
    eventEmitter: NodeJS.EventEmitter;
    /**
     * @type {AppiumLogger}
     */
    _log: AppiumLogger;
    /**
     * @protected
     */
    protected shutdownUnexpectedly: boolean;
    /**
     * @type {boolean}
     */
    shouldValidateCaps: boolean;
    /**
     * @protected
     */
    protected commandsQueueGuard: AsyncLock;
    /**
     * settings should be instantiated by drivers which extend BaseDriver, but
     * we set it to an empty DeviceSettings instance here to make sure that the
     * default settings are applied even if an extending driver doesn't utilize
     * the settings functionality itself
     */
    settings: DeviceSettings<any>;
    get log(): import("@appium/types").AppiumLogger;
    /**
     * Set a callback handler if needed to execute a custom piece of code
     * when the driver is shut down unexpectedly. Multiple calls to this method
     * will cause the handler to be executed mutiple times
     *
     * @param {(...args: any[]) => void} handler The code to be executed on unexpected shutdown.
     * The function may accept one argument, which is the actual error instance, which
     * caused the driver to shut down.
     */
    onUnexpectedShutdown(handler: (...args: any[]) => void): void;
    /**
     * This property is used by AppiumDriver to store the data of the
     * specific driver sessions. This data can be later used to adjust
     * properties for driver instances running in parallel.
     * Override it in inherited driver classes if necessary.
     *
     * @return {Record<string,unknown>} Driver properties mapping
     */
    get driverData(): Record<string, unknown>;
    /**
     * This property controls the way the `executeCommand` method
     * handles new driver commands received from the client.
     * Override it for inherited classes only in special cases.
     *
     * @return {boolean} If the returned value is true (default) then all the commands
     *   received by the particular driver instance are going to be put into the queue,
     *   so each following command will not be executed until the previous command
     *   execution is completed. False value disables that queue, so each driver command
     *   is executed independently and does not wait for anything.
     */
    get isCommandsQueueEnabled(): boolean;
    get eventHistory(): import("@appium/types").EventHistory;
    /**
     * API method for driver developers to log timings for important events
     * @param {string} eventName
     */
    logEvent(eventName: string): void;
    /**
     * @privateRemarks Overridden in appium driver, but here so that individual drivers can be
     * tested with clients that poll
     */
    getStatus(): Promise<{}>;
    /**
     * method required by MJSONWP in order to determine whether it should
     * respond with an invalid session response
     * @param {string} [sessionId]
     * @returns {boolean}
     */
    sessionExists(sessionId?: string | undefined): boolean;
    /**
     * method required by MJSONWP in order to determine if the command should
     * be proxied directly to the driver
     * @param {string} sessionId
     * @returns {Core<C> | null}
     */
    driverForSession(sessionId: string): Core<C> | null;
    isMjsonwpProtocol(): boolean;
    isW3CProtocol(): boolean;
    setProtocolMJSONWP(): void;
    protocol: string | undefined;
    setProtocolW3C(): void;
    /**
     * Check whether a given feature is enabled via its name
     *
     * @param {string} name - name of feature/command
     *
     * @returns {Boolean}
     */
    isFeatureEnabled(name: string): boolean;
    /**
     * Assert that a given feature is enabled and throw a helpful error if it's
     * not
     *
     * @param {string} name - name of feature/command
     * @deprecated
     */
    ensureFeatureEnabled(name: string): void;
    /**
     * Assert that a given feature is enabled and throw a helpful error if it's
     * not
     *
     * @param {string} name - name of feature/command
     */
    assertFeatureEnabled(name: string): void;
    /**
     *
     * @param {string} strategy
     * @param {boolean} [webContext]
     */
    validateLocatorStrategy(strategy: string, webContext?: boolean | undefined): void;
    /**
     *
     * @param {string} [sessionId]
     * @returns {boolean}
     */
    proxyActive(sessionId?: string | undefined): boolean;
    /**
     *
     * @param {string} sessionId
     * @returns {import('@appium/types').RouteMatcher[]}
     */
    getProxyAvoidList(sessionId: string): import('@appium/types').RouteMatcher[];
    /**
     *
     * @param {string} [sessionId]
     * @returns {boolean}
     */
    canProxy(sessionId?: string | undefined): boolean;
    /**
     * Whether a given command route (expressed as method and url) should not be
     * proxied according to this driver
     *
     * @param {string} sessionId - the current sessionId (in case the driver runs
     * multiple session ids and requires it). This is not used in this method but
     * should be made available to overridden methods.
     * @param {import('@appium/types').HTTPMethod} method - HTTP method of the route
     * @param {string} url - url of the route
     * @param {any} [body] - webdriver request body
     *
     * @returns {boolean} - whether the route should be avoided
     */
    proxyRouteIsAvoided(sessionId: string, method: import('@appium/types').HTTPMethod, url: string, body?: any): boolean;
    /**
     *
     * @param {Driver} driver
     */
    addManagedDriver(driver: Driver): void;
    getManagedDrivers(): import("@appium/types").Driver<typeof import("@appium/types").BASE_DESIRED_CAP_CONSTRAINTS, import("@appium/types").StringRecord, any>[];
    clearNewCommandTimeout(): Promise<void>;
}
import { EventEmitter } from "events";
import AsyncLock from "async-lock";
import DeviceSettings from "./device-settings";
//# sourceMappingURL=core.d.ts.map