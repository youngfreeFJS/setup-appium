"use strict";
/* eslint-disable no-unused-vars */
/* eslint-disable require-await */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DriverCore = void 0;
const support_1 = require("@appium/support");
const async_lock_1 = __importDefault(require("async-lock"));
const events_1 = require("events");
const lodash_1 = __importDefault(require("lodash"));
const os_1 = __importDefault(require("os"));
const constants_1 = require("../constants");
const protocol_1 = require("../protocol");
const device_settings_1 = __importDefault(require("./device-settings"));
const helpers_1 = __importDefault(require("./helpers"));
// for compat with running tests transpiled and in-place
const { version: BASEDRIVER_VER } = support_1.fs.readPackageJsonFrom(__dirname);
const NEW_COMMAND_TIMEOUT_MS = 60 * 1000;
const ON_UNEXPECTED_SHUTDOWN_EVENT = 'onUnexpectedShutdown';
/**
 * @template {Constraints} [C=BaseDriverCapConstraints]
 * @implements {Core<C>}
 */
class DriverCore {
    /**
     * @param {DriverOpts<C>} opts
     * @param {boolean} [shouldValidateCaps]
     */
    constructor(opts = /** @type {DriverOpts<C>} */ ({}), shouldValidateCaps = true) {
        /**
         * @type {string?}
         */
        this.sessionId = null;
        this.helpers = helpers_1.default;
        /**
         * basePath is used for several purposes, for example in setting up
         * proxying to other drivers, since we need to know what the base path
         * of any incoming request might look like. We set it to the default
         * initially but it is automatically updated during any actual program
         * execution by the routeConfiguringFunction, which is necessarily run as
         * the entrypoint for any Appium server
         */
        this.basePath = constants_1.DEFAULT_BASE_PATH;
        this.relaxedSecurityEnabled = false;
        /** @type {string[]} */
        this.allowInsecure = [];
        /** @type {string[]} */
        this.denyInsecure = [];
        this.newCommandTimeoutMs = NEW_COMMAND_TIMEOUT_MS;
        this.implicitWaitMs = 0;
        /** @type {string[]} */
        this.locatorStrategies = [];
        /** @type {string[]} */
        this.webLocatorStrategies = [];
        /** @type {Driver[]} */
        this.managedDrivers = [];
        /** @type {NodeJS.Timeout?} */
        this.noCommandTimer = null;
        /** @type {EventHistory} */
        this._eventHistory = { commands: [] };
        // used to handle driver events
        /** @type {NodeJS.EventEmitter} */
        this.eventEmitter = new events_1.EventEmitter();
        /**
         * @protected
         */
        this.shutdownUnexpectedly = false;
        /**
         * @protected
         */
        this.commandsQueueGuard = new async_lock_1.default();
        /**
         * settings should be instantiated by drivers which extend BaseDriver, but
         * we set it to an empty DeviceSettings instance here to make sure that the
         * default settings are applied even if an extending driver doesn't utilize
         * the settings functionality itself
         */
        this.settings = new device_settings_1.default();
        this._log = support_1.logger.getLogger(helpers_1.default.generateDriverLogPrefix(this));
        // setup state
        this.opts = opts;
        // use a custom tmp dir to avoid losing data and app when computer is
        // restarted
        this.opts.tmpDir = this.opts.tmpDir || process.env.APPIUM_TMP_DIR || os_1.default.tmpdir();
        // base-driver internals
        this.shouldValidateCaps = shouldValidateCaps;
        // keeping track of initial opts
        this.initialOpts = lodash_1.default.cloneDeep(opts);
        this.sessionId = null;
    }
    get log() {
        return this._log;
    }
    /**
     * Set a callback handler if needed to execute a custom piece of code
     * when the driver is shut down unexpectedly. Multiple calls to this method
     * will cause the handler to be executed mutiple times
     *
     * @param {(...args: any[]) => void} handler The code to be executed on unexpected shutdown.
     * The function may accept one argument, which is the actual error instance, which
     * caused the driver to shut down.
     */
    onUnexpectedShutdown(handler) {
        this.eventEmitter.on(ON_UNEXPECTED_SHUTDOWN_EVENT, handler);
    }
    /**
     * This property is used by AppiumDriver to store the data of the
     * specific driver sessions. This data can be later used to adjust
     * properties for driver instances running in parallel.
     * Override it in inherited driver classes if necessary.
     *
     * @return {Record<string,unknown>} Driver properties mapping
     */
    get driverData() {
        return {};
    }
    /**
     * This property controls the way the `executeCommand` method
     * handles new driver commands received from the client.
     * Override it for inherited classes only in special cases.
     *
     * @return {boolean} If the returned value is true (default) then all the commands
     *   received by the particular driver instance are going to be put into the queue,
     *   so each following command will not be executed until the previous command
     *   execution is completed. False value disables that queue, so each driver command
     *   is executed independently and does not wait for anything.
     */
    get isCommandsQueueEnabled() {
        return true;
    }
    /*
     * make eventHistory a property and return a cloned object so a consumer can't
     * inadvertently change data outside of logEvent
     */
    get eventHistory() {
        return lodash_1.default.cloneDeep(this._eventHistory);
    }
    /**
     * API method for driver developers to log timings for important events
     * @param {string} eventName
     */
    logEvent(eventName) {
        if (eventName === 'commands') {
            throw new Error('Cannot log commands directly');
        }
        if (typeof eventName !== 'string') {
            throw new Error(`Invalid eventName ${eventName}`);
        }
        if (!this._eventHistory[eventName]) {
            this._eventHistory[eventName] = [];
        }
        const ts = Date.now();
        const logTime = new Date(ts).toTimeString();
        this._eventHistory[eventName].push(ts);
        this.log.debug(`Event '${eventName}' logged at ${ts} (${logTime})`);
    }
    /**
     * @privateRemarks Overridden in appium driver, but here so that individual drivers can be
     * tested with clients that poll
     */
    async getStatus() {
        return {};
    }
    /**
     * method required by MJSONWP in order to determine whether it should
     * respond with an invalid session response
     * @param {string} [sessionId]
     * @returns {boolean}
     */
    sessionExists(sessionId) {
        if (!sessionId)
            return false; // eslint-disable-line curly
        return sessionId === this.sessionId;
    }
    /**
     * method required by MJSONWP in order to determine if the command should
     * be proxied directly to the driver
     * @param {string} sessionId
     * @returns {Core<C> | null}
     */
    driverForSession(sessionId) {
        return this;
    }
    isMjsonwpProtocol() {
        return this.protocol === constants_1.PROTOCOLS.MJSONWP;
    }
    isW3CProtocol() {
        return this.protocol === constants_1.PROTOCOLS.W3C;
    }
    setProtocolMJSONWP() {
        this.protocol = constants_1.PROTOCOLS.MJSONWP;
    }
    setProtocolW3C() {
        this.protocol = constants_1.PROTOCOLS.W3C;
    }
    /**
     * Check whether a given feature is enabled via its name
     *
     * @param {string} name - name of feature/command
     *
     * @returns {Boolean}
     */
    isFeatureEnabled(name) {
        // if we have explicitly denied this feature, return false immediately
        if (this.denyInsecure && lodash_1.default.includes(this.denyInsecure, name)) {
            return false;
        }
        // if we specifically have allowed the feature, return true
        if (this.allowInsecure && lodash_1.default.includes(this.allowInsecure, name)) {
            return true;
        }
        // otherwise, if we've globally allowed insecure features and not denied
        // this one, return true
        if (this.relaxedSecurityEnabled) {
            return true;
        }
        // if we haven't allowed anything insecure, then reject
        return false;
    }
    /**
     * Assert that a given feature is enabled and throw a helpful error if it's
     * not
     *
     * @param {string} name - name of feature/command
     * @deprecated
     */
    ensureFeatureEnabled(name) {
        this.assertFeatureEnabled(name);
    }
    /**
     * Assert that a given feature is enabled and throw a helpful error if it's
     * not
     *
     * @param {string} name - name of feature/command
     */
    assertFeatureEnabled(name) {
        if (!this.isFeatureEnabled(name)) {
            throw new Error(`Potentially insecure feature '${name}' has not been ` +
                `enabled. If you want to enable this feature and accept ` +
                `the security ramifications, please do so by following ` +
                `the documented instructions at https://github.com/appium` +
                `/appium/blob/master/docs/en/writing-running-appium/security.md`);
        }
    }
    /**
     *
     * @param {string} strategy
     * @param {boolean} [webContext]
     */
    validateLocatorStrategy(strategy, webContext = false) {
        let validStrategies = this.locatorStrategies;
        this.log.debug(`Valid locator strategies for this request: ${validStrategies.join(', ')}`);
        if (webContext) {
            validStrategies = validStrategies.concat(this.webLocatorStrategies);
        }
        if (!lodash_1.default.includes(validStrategies, strategy)) {
            throw new protocol_1.errors.InvalidSelectorError(`Locator Strategy '${strategy}' is not supported for this session`);
        }
    }
    /**
     *
     * @param {string} [sessionId]
     * @returns {boolean}
     */
    proxyActive(sessionId) {
        return false;
    }
    /**
     *
     * @param {string} sessionId
     * @returns {import('@appium/types').RouteMatcher[]}
     */
    getProxyAvoidList(sessionId) {
        return [];
    }
    /**
     *
     * @param {string} [sessionId]
     * @returns {boolean}
     */
    canProxy(sessionId) {
        return false;
    }
    /**
     * Whether a given command route (expressed as method and url) should not be
     * proxied according to this driver
     *
     * @param {string} sessionId - the current sessionId (in case the driver runs
     * multiple session ids and requires it). This is not used in this method but
     * should be made available to overridden methods.
     * @param {import('@appium/types').HTTPMethod} method - HTTP method of the route
     * @param {string} url - url of the route
     * @param {any} [body] - webdriver request body
     *
     * @returns {boolean} - whether the route should be avoided
     */
    proxyRouteIsAvoided(sessionId, method, url, body) {
        for (let avoidSchema of this.getProxyAvoidList(sessionId)) {
            if (!lodash_1.default.isArray(avoidSchema) || avoidSchema.length !== 2) {
                throw new Error('Proxy avoidance must be a list of pairs');
            }
            let [avoidMethod, avoidPathRegex] = avoidSchema;
            if (!lodash_1.default.includes(['GET', 'POST', 'DELETE'], avoidMethod)) {
                throw new Error(`Unrecognized proxy avoidance method '${avoidMethod}'`);
            }
            if (!lodash_1.default.isRegExp(avoidPathRegex)) {
                throw new Error('Proxy avoidance path must be a regular expression');
            }
            let normalizedUrl = url.replace(new RegExp(`^${lodash_1.default.escapeRegExp(this.basePath)}`), '');
            if (avoidMethod === method && avoidPathRegex.test(normalizedUrl)) {
                return true;
            }
        }
        return false;
    }
    /**
     *
     * @param {Driver} driver
     */
    addManagedDriver(driver) {
        this.managedDrivers.push(driver);
    }
    getManagedDrivers() {
        return this.managedDrivers;
    }
    async clearNewCommandTimeout() {
        if (this.noCommandTimer) {
            clearTimeout(this.noCommandTimer);
            this.noCommandTimer = null;
        }
    }
}
exports.DriverCore = DriverCore;
/**
 * Make the basedriver version available so for any driver which inherits from this package, we
 * know which version of basedriver it inherited from
 */
DriverCore.baseVersion = BASEDRIVER_VER;
/** @type {import('@appium/types').ExecuteMethodMap<DriverCore>} */
DriverCore.executeMethodMap = {};
/**
 * @typedef {import('@appium/types').Driver} Driver
 * @typedef {import('@appium/types').Constraints} Constraints
 * @typedef {import('@appium/types').ServerArgs} ServerArgs
 * @typedef {import('@appium/types').EventHistory} EventHistory
 * @typedef {import('@appium/types').AppiumLogger} AppiumLogger
 * @typedef {import('@appium/types').StringRecord} StringRecord
 * @typedef {import('@appium/types').BaseDriverCapConstraints} BaseDriverCapConstraints
 */
/**
 * @template {Constraints} [C=BaseDriverCapConstraints]
 * @template {StringRecord|void} [Extra=void]
 * @typedef {import('@appium/types').Capabilities<C, Extra>} Capabilities
 */
/**
 * @template {StringRecord} [T={}]
 * @typedef {import('@appium/types').W3CCapabilities<T>} W3CCapabilities
 */
/**
 * @template {Constraints} C
 * @typedef {import('@appium/types').Core<C>} Core
 */
/**
 * @template {Constraints} C
 * @typedef {import('@appium/types').DriverOpts<C>} DriverOpts
 */
//# sourceMappingURL=core.js.map