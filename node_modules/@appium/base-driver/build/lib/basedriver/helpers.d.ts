declare const _default: import("@appium/types").DriverHelpers<any>;
export default _default;
export type PostProcessOptions = {
    /**
     * The information about the previously cached app instance (if exists):
     * - packageHash: SHA1 hash of the package if it is a file and not a folder
     * - lastModified: Optional Date instance, the value of file's `Last-Modified` header
     * - immutable: Optional boolean value. Contains true if the file has an `immutable` mark
     * in `Cache-control` header
     * - maxAge: Optional integer representation of `maxAge` parameter in `Cache-control` header
     * - timestamp: The timestamp this item has been added to the cache (measured in Unix epoch
     * milliseconds)
     * - integrity: An object containing either `file` property with SHA1 hash of the file
     * or `folder` property with total amount of cached files and subfolders
     * - fullPath: the full path to the cached app
     */
    cachedAppInfo: any | null;
    /**
     * Whether the app has been downloaded from a remote URL
     */
    isUrl: boolean;
    /**
     * Optional headers object. Only present if `isUrl` is true and if the server
     * responds to HEAD requests. All header names are normalized to lowercase.
     */
    headers: any | null;
    /**
     * A string containing full path to the preprocessed application package (either
     * downloaded or a local one)
     */
    appPath: string;
};
export type PostProcessResult = {
    /**
     * The full past to the post-processed application package on the
     * local file system (might be a file or a folder path)
     */
    appPath: string;
};
export type ConfigureAppOptions = {
    /**
     * Optional function, which should be applied
     * to the application after it is downloaded/preprocessed. This function may be async
     * and is expected to accept single object parameter.
     * The function is expected to either return a falsy value, which means the app must not be
     * cached and a fresh copy of it is downloaded each time. If this function returns an object
     * containing `appPath` property then the integrity of it will be verified and stored into
     * the cache.
     */
    onPostProcess?: ((obj: PostProcessOptions) => (Promise<PostProcessResult | undefined> | PostProcessResult | undefined)) | undefined;
    /**
     * List of supported application extensions (
     * including starting dots). This property is mandatory and must not be empty.
     */
    supportedExtensions: string[];
};
export type RemoteAppProps = {
    lastModified: Date | null;
    immutable: boolean;
    maxAge: number | null;
};
/**
 * @typedef PostProcessOptions
 * @property {?Object} cachedAppInfo The information about the previously cached app instance (if exists):
 *    - packageHash: SHA1 hash of the package if it is a file and not a folder
 *    - lastModified: Optional Date instance, the value of file's `Last-Modified` header
 *    - immutable: Optional boolean value. Contains true if the file has an `immutable` mark
 *                 in `Cache-control` header
 *    - maxAge: Optional integer representation of `maxAge` parameter in `Cache-control` header
 *    - timestamp: The timestamp this item has been added to the cache (measured in Unix epoch
 *                 milliseconds)
 *    - integrity: An object containing either `file` property with SHA1 hash of the file
 *                 or `folder` property with total amount of cached files and subfolders
 *    - fullPath: the full path to the cached app
 * @property {boolean} isUrl Whether the app has been downloaded from a remote URL
 * @property {?Object} headers Optional headers object. Only present if `isUrl` is true and if the server
 * responds to HEAD requests. All header names are normalized to lowercase.
 * @property {string} appPath A string containing full path to the preprocessed application package (either
 * downloaded or a local one)
 */
/**
 * @typedef PostProcessResult
 * @property {string} appPath The full past to the post-processed application package on the
 * local file system (might be a file or a folder path)
 */
/**
 * @typedef ConfigureAppOptions
 * @property {(obj: PostProcessOptions) => (Promise<PostProcessResult|undefined>|PostProcessResult|undefined)} [onPostProcess]
 * Optional function, which should be applied
 * to the application after it is downloaded/preprocessed. This function may be async
 * and is expected to accept single object parameter.
 * The function is expected to either return a falsy value, which means the app must not be
 * cached and a fresh copy of it is downloaded each time. If this function returns an object
 * containing `appPath` property then the integrity of it will be verified and stored into
 * the cache.
 * @property {string[]} supportedExtensions List of supported application extensions (
 * including starting dots). This property is mandatory and must not be empty.
 */
/**
 * Prepares an app to be used in an automated test. The app gets cached automatically
 * if it is an archive or if it is downloaded from an URL.
 * If the downloaded app has `.zip` extension, this method will unzip it.
 * The unzip does not work when `onPostProcess` is provided.
 *
 * @param {string} app Either a full path to the app or a remote URL
 * @param {string|string[]|ConfigureAppOptions} options
 * @returns The full path to the resulting application bundle
 */
export function configureApp(app: string, options?: string | string[] | ConfigureAppOptions): Promise<any>;
export function isPackageOrBundle(app: any): boolean;
/**
 * Finds all instances 'firstKey' and create a duplicate with the key 'secondKey',
 * Do the same thing in reverse. If we find 'secondKey', create a duplicate with the key 'firstKey'.
 *
 * This will cause keys to be overwritten if the object contains 'firstKey' and 'secondKey'.

 * @param {*} input Any type of input
 * @param {String} firstKey The first key to duplicate
 * @param {String} secondKey The second key to duplicate
 */
export function duplicateKeys(input: any, firstKey: string, secondKey: string): any;
/**
 * Takes a desired capability and tries to JSON.parse it as an array,
 * and either returns the parsed array or a singleton array.
 *
 * @param {string|Array<String>} cap A desired capability
 */
export function parseCapsArray(cap: string | Array<string>): any[];
/**
 * Generate a string that uniquely describes driver instance
 *
 * @param {import('@appium/types').Core} obj driver instance
 * @param {string?} sessionId session identifier (if exists)
 * @returns {string}
 */
export function generateDriverLogPrefix(obj: import('@appium/types').Core, sessionId?: string | null): string;
//# sourceMappingURL=helpers.d.ts.map